---
"description": "General engineering standard for all generated or modified code.\n\nPRINCIPLES\n- Prefer small, composable modules with clear separation of concerns (pure domain logic separate from IO, frameworks, and infrastructure).\n- Keep code simple, explicit, and idiomatic; avoid cleverness and over-engineering.\n- Favour immutability and pure functions where practical. Design for testability.\n- Follow SOLID and DRY pragmatically; duplicate only when it truly reduces coupling.\n\nHARD LIMITS (enforce by refactoring before adding new code)\n- File length: ≤ 300 lines (tests may exceed when parametrised, but keep focused).\n- Function/method length: ≤ 40 logical lines; cyclomatic complexity ≤ 10.\n- Public class size: ≤ 400 lines including docstrings; prefer composition over large classes.\n\nTYPING, DOCS, & STYLE (Python)\n- Use full type hints everywhere; pass mypy --strict. Prefer Protocols, TypedDict, and generics for boundaries.\n- Add Google-style docstrings for all public APIs (module, class, function). Include Args, Returns, Raises, and Examples where useful.\n- Use logging (structured where possible) rather than print; never swallow exceptions.\n- Follow Ruff/Black/isort defaults; organise imports; no unused code.\n\nARCHITECTURE & LAYOUT (Python)\n- Standard layout:\n  - pyproject.toml (tools config)\n  - src/<package>/ (no top-level runtime code; keep __init__ minimal)\n  - tests/ (mirrors package layout; fast, isolated, deterministic)\n  - scripts/ for thin CLIs that delegate to src logic\n  - docs/ for user/developer guides\n- Boundaries:\n  - domain/ (pure business logic, no external imports except stdlib typing)\n  - adapters/ (IO: DB, HTTP, file system, cloud SDKs)\n  - services/use_cases/ (application orchestration; depends on domain & ports)\n  - ports/ (interfaces/protocols used by domain/services)\n- No circular imports. Public API surface kept intentionally small (export via __all__ when helpful).\n\nERROR HANDLING\n- Validate inputs at boundaries; fail fast with precise custom exceptions derived from a small hierarchy.\n- Convert low-level exceptions at boundaries; never leak infrastructure types across layers.\n\nASYNC & CONCURRENCY\n- Use async/await for IO-bound paths; keep domain logic synchronous and pure.\n- Avoid shared mutable state; prefer context objects or explicit parameters.\n\nTESTING\n- Write pytest unit tests for all public behaviours first (AAA pattern); aim for >90% critical-path coverage.\n- Use fakes over mocks where possible; mock only true boundaries (IO, time, randomness, environment).\n- Property-based tests for key invariants; regression tests for fixed bugs.\n\nCONFIGURATION & ENVIRONMENT\n- No hard-coded paths/secrets; configure via env vars or a single settings module/class. Provide safe defaults.\n\nCODE REVIEW CHECKLIST (apply before completing any change)\n- [ ] Files/functions within limits; names precise and consistent.\n- [ ] Separation of concerns preserved; boundaries remain directional.\n- [ ] Types complete; mypy --strict and ruff pass.\n- [ ] Docstrings and module docs added/updated.\n- [ ] Tests added/updated; run fast and deterministic.\n- [ ] No dead code, TODOs justified with issue links.\n\nAVOID\n- God classes, long parameter lists (>7), deep inheritance, premature abstraction.\n- Leaking framework/ORM types into domain logic.\n- Wide catch-alls, print debugging, hidden I/O in pure functions.\n\nOUTPUT EXPECTATIONS FROM THE ASSISTANT\n- Propose refactors to keep within limits (split files/modules when approaching limits).\n- Default to creating new small modules over growing an existing large one.\n- Include minimal, focused examples and tests when generating new APIs.\n- Explain any trade-offs briefly in comments or commit messages when constraints must be bent.",
"globs": ["*"],
"alwaysApply": true
---
